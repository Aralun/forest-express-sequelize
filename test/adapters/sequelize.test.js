const Sequelize = require('sequelize');
const getSchema = require('../../src/adapters/sequelize');
const { sequelizePostgres, sequelizeMySQLMin, sequelizeMySQLMax } = require('../databases');

function getField(schema, name) {
  return schema.fields.find((field) => field.field === name);
}

[sequelizePostgres, sequelizeMySQLMin, sequelizeMySQLMax].forEach((sequelize) => {
  const models = {};
  const sequelizeOptions = {
    sequelize: Sequelize,
    connections: [sequelize],
  };

  models.user = sequelize.define('user', {
    username: { type: Sequelize.STRING },
    role: { type: Sequelize.ENUM(['admin', 'user']) },
    permissions: {
      type: Sequelize.ARRAY(Sequelize.ENUM([
        'documents:write',
        'documents:read',
      ])),
    },
  });

  describe(`with dialect ${sequelize.options.dialect} (port: ${sequelize.options.port})`, () => {
    describe('with model `users`', () => {
      it('should set name correctly', async () => {
        expect.assertions(1);

        const schema = await getSchema(models.user, sequelizeOptions);
        expect(schema.name).toStrictEqual('user');
      });

      it('should set idField to id', async () => {
        expect.assertions(1);

        const schema = await getSchema(models.user, sequelizeOptions);
        expect(schema.idField).toStrictEqual('id');
      });

      it('should set primaryKeys to [id]', async () => {
        expect.assertions(1);

        const schema = await getSchema(models.user, sequelizeOptions);
        expect(schema.primaryKeys).toStrictEqual(['id']);
      });

      it('should set isCompositePrimary to false', async () => {
        expect.assertions(1);

        const schema = await getSchema(models.user, sequelizeOptions);
        expect(schema.isCompositePrimary).toStrictEqual(false);
      });

      describe('when setting fields values', () => {
        it('should generate id field', async () => {
          expect.assertions(1);

          const schema = await getSchema(models.user, sequelizeOptions);
          expect(getField(schema, 'id')).toStrictEqual({
            field: 'id',
            type: 'Number',
            columnName: 'id',
            primaryKey: true,
            isGenerated: true,
          });
        });

        it('should set username field', async () => {
          expect.assertions(1);

          const schema = await getSchema(models.user, sequelizeOptions);
          expect(getField(schema, 'username')).toStrictEqual({
            field: 'username',
            type: 'String',
            columnName: 'username',
            isGenerated: false,
          });
        });

        it('should handle enum (role field)', async () => {
          expect.assertions(1);

          const schema = await getSchema(models.user, sequelizeOptions);
          expect(getField(schema, 'role')).toStrictEqual({
            field: 'role',
            type: 'Enum',
            columnName: 'role',
            enums: ['admin', 'user'],
            isGenerated: false,
          });
        });

        it('should handle array of enum (role field)', async () => {
          expect.assertions(1);

          const schema = await getSchema(models.user, sequelizeOptions);
          expect(getField(schema, 'permissions')).toStrictEqual({
            field: 'permissions',
            type: ['Enum'],
            columnName: 'permissions',
            enums: ['documents:write', 'documents:read'],
            isGenerated: false,
          });
        });

        it('should generate timestamps', async () => {
          expect.assertions(2);

          const schema = await getSchema(models.user, sequelizeOptions);
          expect(getField(schema, 'createdAt')).toStrictEqual({
            field: 'createdAt',
            type: 'Date',
            columnName: 'createdAt',
            isGenerated: true,
          });
          expect(getField(schema, 'updatedAt')).toStrictEqual({
            field: 'updatedAt',
            type: 'Date',
            columnName: 'updatedAt',
            isGenerated: true,
          });
        });
      });
    });

    describe('with non-autogenerated ids', () => {
      const model = sequelize.define('post', {
        id: {
          type: Sequelize.UUID,
          primaryKey: true,
        },
        title: {
          type: Sequelize.STRING,
        },
      });

      it('should identify the id as required and not generated', async () => {
        expect.assertions(1);

        const schema = await getSchema(model, sequelizeOptions);
        expect(getField(schema, 'id')).toStrictEqual({
          field: 'id',
          type: 'String',
          columnName: 'id',
          isGenerated: false,
          isRequired: true,
          primaryKey: true,
        });
      });
    });

    describe('with dynamically generated columns', () => {
      const model = sequelize.define('islands', {
        name: { type: Sequelize.STRING },
        rating: { type: Sequelize.INTEGER, defaultValue: () => 5 },
        createdAt: { type: Sequelize.DATE, defaultValue: Sequelize.NOW },
      });

      it('should identify the rating column as generated', async () => {
        expect.assertions(1);

        const schema = await getSchema(model, sequelizeOptions);
        expect(getField(schema, 'rating')).toStrictEqual({
          field: 'rating',
          type: 'Number',
          columnName: 'rating',
          isGenerated: true,
          isRequired: false,
        });
      });

      it('should identify the createdAt column as generated', async () => {
        expect.assertions(1);

        const schema = await getSchema(model, sequelizeOptions);
        expect(getField(schema, 'createdAt')).toStrictEqual({
          field: 'createdAt',
          type: 'Date',
          columnName: 'createdAt',
          isGenerated: true,
          isRequired: false,
        });
      });
    });
  });
});
